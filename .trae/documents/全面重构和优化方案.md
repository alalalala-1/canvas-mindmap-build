## 重构目标
在不破坏现有功能的前提下，进行全面重构和优化，提高代码质量、可维护性和性能。

## 高优先级重构（立即执行）

### 1. 提取公共工具函数，消除重复代码

**问题**: `getCurrentCanvasFilePath`、`getCanvasView`、`getNodeIdFromEdgeEndpoint` 在 5+ 个文件中重复

**方案**:
- 创建 `src/utils/canvas-utils.ts` 统一处理 Canvas 相关工具函数
- 所有 Manager 类通过导入使用这些函数

**涉及文件**:
- canvas-manager.ts
- canvas-event-manager.ts
- floating-node-manager.ts
- canvas-node-manager.ts
- canvas-ui-manager.ts

### 2. 修复内存泄漏

**问题**: 
- `clickDebounceMap` 没有清理机制
- 定时器和观察者可能未正确销毁

**方案**:
- 为 Map 添加清理机制（LRU 或定期清理）
- 确保 `unload()` 方法正确销毁所有资源

### 3. 减少 `any` 类型使用

**问题**: 项目中 `any` 出现超过 100 次

**方案**:
- 定义 Canvas 相关接口（CanvasNode, CanvasEdge, CanvasView 等）
- 逐步替换关键路径上的 `any` 类型

## 中优先级重构（近期执行）

### 4. 统一错误处理

**方案**:
- 创建错误处理工具函数
- 统一用户通知机制（Notice）
- 添加错误边界处理

### 5. 性能优化

**方案**:
- 缓存 DOM 查询结果
- 减少文件读取次数（使用内存缓存）
- 优化布局算法（添加记忆化）

### 6. 代码重构

**方案**:
- 拆分过长函数（`arrangeCanvas`、`addNodeToCanvas` 等）
- 提取魔法数字为常量
- 统一正则表达式定义

## 低优先级重构（长期改进）

### 7. 架构优化

**方案**:
- 引入事件总线解耦 Manager 类
- 考虑使用状态管理库

### 8. 合并重复 Manager

**方案**:
- 合并 `CanvasNodeManager` 和 `NodeManager`
- 明确 `EdgeManager` 和 `CanvasEventManager` 的职责分工

## 实施计划

### 阶段 1：工具函数提取（1-2 天）
1. 创建 `canvas-utils.ts`
2. 提取 `getCurrentCanvasFilePath`、`getCanvasView`、`getNodeIdFromEdgeEndpoint`
3. 替换所有文件中的重复代码

### 阶段 2：类型定义完善（1-2 天）
1. 扩展 `types.ts` 定义 Canvas 相关接口
2. 替换关键路径上的 `any` 类型

### 阶段 3：内存泄漏修复（1 天）
1. 修复 `clickDebounceMap` 清理
2. 确保所有资源正确销毁

### 阶段 4：性能优化（2-3 天）
1. 实现 DOM 查询缓存
2. 优化文件读取
3. 优化布局算法

### 阶段 5：代码重构（2-3 天）
1. 拆分过长函数
2. 提取常量
3. 统一错误处理

## 风险评估

### 低风险
- 提取工具函数（纯重构，不改变逻辑）
- 添加类型定义（编译时检查）
- 提取常量（不改变行为）

### 中风险
- 修复内存泄漏（需要仔细测试生命周期）
- 性能优化（需要验证性能提升）

### 高风险
- 合并 Manager 类（可能影响功能）
- 架构重构（需要全面测试）

## 测试策略

1. **单元测试**: 为提取的工具函数添加测试
2. **集成测试**: 测试 Manager 类之间的协作
3. **手动测试**: 验证所有功能正常工作
4. **性能测试**: 对比重构前后的性能

## 预期收益

1. **代码质量**: 减少 50%+ 的重复代码
2. **可维护性**: 统一的类型定义和错误处理
3. **性能**: 减少 DOM 查询和文件读取次数
4. **稳定性**: 修复内存泄漏，减少崩溃