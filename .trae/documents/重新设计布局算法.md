## 问题分析

从截图和日志可以看出：

1. **第一次布局**：正常节点（1w5gj6f0 和 23n193mr）被推到 y=1160，因为浮动节点 yeu7ch9s 在 y=429，正常节点为了避开它而被推到下方
2. **第二次布局**：j7d0dlue 被移到 y=1189，远离其他节点

根本问题：当前算法在 Y 方向上过于严格地避开浮动节点，导致正常节点被推到很远的地方。

## 改进方案

### 方案：浮动节点完全独立

让浮动节点完全独立于正常节点的布局计算：

1. **布局计算阶段**：完全不考虑浮动节点
   - 正常节点按自己的树形结构布局
   - 浮动节点保持原位，不参与任何计算

2. **碰撞检测阶段**：只在最终渲染时检查
   - 如果正常节点与浮动节点重叠，微调正常节点的 Y 位置
   - 调整范围限制在较小范围内（如 ±50 像素）
   - 如果无法避免重叠，保持原位置（接受轻微重叠）

3. **移除 Y 方向避让逻辑**
   - 删除 `checkYOverlapWithFixed` 函数
   - 删除 `findNonOverlappingY` 函数
   - 简化 `applyAbsolutePositions` 函数

### 具体实施步骤

1. 修改 `arrangeLayout` 函数：
   - 移除 `fixedNodeYRanges` 收集
   - 移除 Y 方向重叠检测
   - 简化布局逻辑

2. 在 `layout-manager.ts` 中：
   - 布局完成后，检查是否有正常节点与浮动节点重叠
   - 如果有，微调正常节点的 Y 位置（小范围）
   - 保持 X 坐标不变

3. 测试验证：
   - 正常节点应该按树形结构紧凑布局
   - 浮动节点保持在原位
   - 即使重叠，也只是轻微重叠，不影响整体美观

## 预期效果

- 正常节点不再被推到很远的地方
- 布局更紧凑、更美观
- 浮动节点作为"装饰性"元素，不影响主体布局

请确认这个方案后，我将开始实施具体的代码修改。