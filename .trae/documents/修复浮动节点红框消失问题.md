## 问题分析

发现有三处代码在清除浮动状态，逻辑不一致：

1. **`canvas:edge-created` 事件**（canvas-event-manager.ts 第 79、82 行）
   - 清除源节点和目标节点的浮动状态
   
2. **Canvas 的 `edge-add` 事件**（canvas-event-manager.ts 第 376、382 行）
   - 清除源节点和目标节点的浮动状态
   
3. **`EdgeChangeDetection` 轮询**（floating-node-manager.ts）
   - 只清除目标节点的浮动状态

这导致行为混乱：
- 有时源节点的红框被错误清除
- 有时目标节点的红框没有被清除

## 修复方案

统一所有地方的逻辑：**只清除目标节点的浮动状态**

### 修改 1：canvas-event-manager.ts（canvas:edge-created 事件）
- 移除清除源节点浮动状态的代码（第 78-80 行）
- 只保留清除目标节点浮动状态的代码（第 81-83 行）

### 修改 2：canvas-event-manager.ts（edge-add 事件）
- 移除清除源节点浮动状态的代码（第 374-378 行）
- 只保留清除目标节点浮动状态的代码（第 380-386 行）

### 修改 3：floating-node-manager.ts（已修复）
- 已经只清除目标节点，无需修改

## 预期效果

- 连接浮动节点 A → A 的红框消失（A 是目标节点）
- 连接浮动节点 B → B 的红框消失（B 是目标节点）
- 源节点（发出连接的节点）的红框不受影响