## 需求理解

1. 浮动节点作为原父节点的**正常子节点**
2. 参与折叠、展开、arrange 布局（**不做特殊处理**）
3. 只是**不显示连线**（没有真实的边）
4. 连接到新父节点后，变成新父节点的正常子节点

## 正确的实现方式

### 核心思想

**浮动节点就是普通子节点，只是没有边连接。**

不应该：
- ❌ 在布局时过滤浮动节点
- ❌ 对浮动节点做特殊的位置计算
- ❌ 添加 `isFloatingSubtreeRoot` 特殊处理

应该：
- ✅ 将浮动节点添加到 `children` 列表
- ✅ 正常计算子树高度和位置
- ✅ 和普通子节点一样参与布局

### 代码修改

#### 1. 简化 `applyAbsolutePositions` - 移除浮动节点特殊处理

```typescript
function applyAbsolutePositions(nodeId: string, parentY: number = 0) {
    const node = layoutNodes.get(nodeId);
    if (!node) return;

    // 设置当前节点的Y坐标
    if (parentY === 0 && rootNodes.includes(nodeId)) {
        node.y = 0;
    } else {
        node.y = parentY;
    }

    // 递归处理所有子节点（包括浮动节点）
    if (node.children.length > 0) {
        // 计算所有子节点总高度（包括浮动节点）
        let childrenTotalHeight = 0;
        for (const childId of node.children) {
            const childNode = layoutNodes.get(childId);
            if (childNode) {
                childrenTotalHeight += childNode._subtreeHeight;
            }
        }
        childrenTotalHeight += Math.max(0, node.children.length - 1) * settings.verticalSpacing;

        // 计算子节点的理想起始Y位置（垂直居中）
        const idealChildrenStartY = node.y + (node.height / 2) - (childrenTotalHeight / 2);
        const childrenStartY = Math.max(node.y, idealChildrenStartY);

        // 设置每个子节点的位置（包括浮动节点）
        let currentY = childrenStartY;
        for (const childId of node.children) {
            const childNode = layoutNodes.get(childId);
            if (childNode) {
                applyAbsolutePositions(childId, currentY);
                currentY += childNode._subtreeHeight + settings.verticalSpacing;
            }
        }
    }
}
```

#### 2. 简化 `calculateSubtreeHeight` - 移除浮动节点特殊处理

```typescript
function calculateSubtreeHeight(nodeId: string): number {
    const node = layoutNodes.get(nodeId);
    if (!node) return 0;

    // 处理所有子节点（包括浮动节点）
    if (node.children.length === 0) {
        node._subtreeHeight = node.height;
        return node.height;
    }

    let childrenTotalHeight = 0;
    for (const childId of node.children) {
        const childHeight = calculateSubtreeHeight(childId);
        childrenTotalHeight += childHeight;
    }
    childrenTotalHeight += Math.max(0, node.children.length - 1) * settings.verticalSpacing;

    node._subtreeHeight = Math.max(node.height, childrenTotalHeight);
    return node._subtreeHeight;
}
```

#### 3. 保留虚拟边创建，但仅用于识别父子关系

```typescript
// 创建虚拟边：为浮动子树添加虚拟连接到原父节点
floatingSubtreeRoots.forEach(rootId => {
    const originalParentId = floatingSubtreeOriginalParents.get(rootId);
    if (originalParentId) {
        const parentNode = layoutNodes.get(originalParentId);
        const childNode = layoutNodes.get(rootId);
        if (parentNode && childNode) {
            // 将浮动节点添加到 children 列表（作为正常子节点）
            if (!parentNode.children.includes(rootId)) {
                parentNode.children.push(rootId);
            }
            layoutParentMap.set(rootId, originalParentId);
        }
    }
});
```

#### 4. 移除整体平移逻辑

```typescript
// 移除这部分代码
// if (minY < 0) {
//     const offsetY = -minY;
//     layoutNodes.forEach((node) => {
//         node.y += offsetY;
//     });
// }
```

### 关键修改总结

1. **移除 `isFloatingSubtreeRoot` 参数** - 浮动节点就是普通子节点
2. **移除子节点过滤逻辑** - 所有子节点（包括浮动）都参与布局
3. **移除整体平移逻辑** - 保持原有的相对位置
4. **保留虚拟边创建** - 仅用于将浮动节点添加到 `children` 列表

### 预期效果

1. 浮动节点作为原父节点的正常子节点参与布局
2. 折叠、展开、arrange 都正常工作
3. 只是不显示连线（因为没有真实的边）
4. 连接到新父节点后，变成新父节点的正常子节点