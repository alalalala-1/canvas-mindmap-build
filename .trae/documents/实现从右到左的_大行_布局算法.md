## 问题分析

从截图和日志可以看出：
1. 边的锚定点不是优雅的左右关系，而是斜着的
2. 子节点的位置比父节点还靠左（9hz0tpea 在 x=1706，但它的祖父节点 yeu7ch9s 在 x=1106）
3. 整体布局不协调

根本原因：当前的布局算法是**从左到右**的，但用户想要的是**从右到左**的"大行"布局。

## 用户提供的布局思路

1. 从最右边（最后一层子节点）开始
2. 从上到下，按照到倒数第二层对应的父节点的归属关系，先进行居中
3. 再由倒数第二层节点，从上到下继续向左边的倒数第三层父节点居中（同时整体移动后续所有层级子节点的位置）
4. 以此类推，一直到正数第二层父节点
5. 这样从右到左居中调整完的各层级node算是一个"大行"
6. 然后开始下一个"大行"的调整工作：找出上一个"大行"里，哪个节点层级的高度最高，以此为基准再加上间隔

## 实现方案

### 1. 重新设计布局算法（高优先级）

完全重写 `arrangeLayout` 函数，实现从右到左的布局：

1. **收集所有树结构**：找出所有根节点及其子树
2. **从右到左布局每个树**：
   - 对每个树，从最深层级开始
   - 计算每个节点的子树高度
   - 从右到左逐层计算位置
3. **处理多个树（大行）**：
   - 计算每个树的最大高度
   - 根据前一个树的位置，计算当前树的起始位置
   - 添加间隔

### 2. 关键数据结构

```typescript
interface TreeLayout {
    rootId: string;
    nodes: Map<string, LayoutNode>;
    maxLevel: number;
    totalHeight: number;
}
```

### 3. 布局步骤

1. **构建树结构**：找出所有根节点和父子关系
2. **计算子树高度**：从叶子节点向上计算
3. **从右到左布局**：
   - 对每个树，从最深层级开始
   - 子节点垂直居中于父节点
   - 父节点的位置基于所有子节点的位置
4. **处理多个树**：
   - 计算每个树的总高度
   - 根据前一个树的位置 + 间隔，计算当前树的位置

### 4. 边锚定点优化

- 父节点的右边中点 → 子节点的左边中点
- 确保连线是水平的，不是斜的

## 实施步骤

1. 完全重写 `arrangeLayout` 函数
2. 实现从右到左的布局逻辑
3. 实现"大行"（多棵树）的处理
4. 测试验证

## 预期效果

- 布局从右到左，符合思维导图习惯
- 子节点垂直居中于父节点
- 多个树（大行）之间有良好的间隔
- 连线是优雅的左右关系，不是斜的

请确认这个方案后，我将开始实施具体的代码修改。